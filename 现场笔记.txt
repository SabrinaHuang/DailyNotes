2016年4月7日 11:23:29
		react Native的用法
		
		*调用原生iOS控件的法子		
		// 貌似是引用react,并且引用tab和Nav
		var React = require("")
		var {TabBarIOS, NavigatorIOS } = React;
		
		var App = React.createClass({
			// 渲染函数
			render: function(){
				return(
				// 也是用js里对元素的修饰来实现的
				<TabBarIOS>
					<TabBarIOS.Item title = "React Native" selected={true} >
							<NavIOS initialRoute ={{title: 'React Native'}} />
					</TabBarIOS.Item>
				</TabBarIOS>
				);			
			},		
		}	
		);
       

	
		react 模拟iOS中的触摸	
		var React = require("")
		var {ScrollView, TouchableHighlight, Text} = React;
		var TouchDemo = React.createClass({
			// 渲染控件的样式
			render:function(){
				<ScrollView>
				  //  可以渲染事件
				  <TouchableHighlight onPress={()=>console.log('pressed')} >
					<Text>Proper Touch Handling</Text>
				  </TouchableHighlight>
				</scrollView>
			},
		});
	
	
		*在JS里，render表示渲染。给元素添加样式，布局，事件
		
		react 实现iOS里的样式设置
		var React = require('react-native');
		// 相当于import各组件
		var { Image, StyleSheet, Text, View } = React;
		var ReactNative = React.createClass({
			render: function() {
				return (
					<View style={styles.row}>
						<Image	source={{uri: 'http://facebook.github.io/react/img/logo_og.png'}} style={styles.image}/>
						<View style={styles.text}>
						<Text style={styles.title}>
							React Native
						</Text>
						
						<Text style={styles.subtitle}>
							Build high quality mobile apps using React
						</Text>					
						</View>
					</View>
		);
	},
	});
	
	// react Native提供各控件渲染样式的stylesheet
	var styles = StyleSheet.create({
		row: { flexDirection: 'row', margin: 40 },
		image: { width: 40, height: 40, marginRight: 10 },
		text: { flex: 1, justifyContent: 'center'},
		title: { fontSize: 11, fontWeight: 'bold' },
		subtitle: { fontSize: 10 },
	});
		
	
	*npm（node package manager） 功能同cocoPods,用于分发和管理NodeJS包
	
	
	*NodeJS  是基于JS runtime的平台。
	
	*runtime 
		是一段程序运行时，除了 bare-metal之外的调用
		特点是：
			1、在程序运行时，介入的频率不是太高
			2、由此语言独享
			
			
	// 	react 本身融入 JS的API，比如XMLHttpRequest,navigator.geolocation等
	var React = require('react-native');
	var { Text } = React;
		*指定了三个对象
	var GeoInfo = React.createClass({
		getInitialState: function() {
		return { position: 'unknown' };
	},	
	
	componentDidMount: function() {
		navigator.geolocation.getCurrentPosition(
			(position) => this.setState({position}),
			(error) => console.error(error)
		);
	},
	
	render: function() {
	   return (
		  <Text>
			Position: {JSON.stringify(this.state.position)}
		  </Text>
		);
	   },
	});
	
	
	//  react可以重用原生代码。做法是包装对JS可用的功能，并用RCT_EXPORT_MODULE() 显式导出	
	// Objective-C,封装了原有的类，让JS可通过RCT_EXPORT_METHOD
	#import "RCTBridgeModule.h"
	@interface MyCustomModule : NSObject <RCTBridgeModule>
	@end

	@implementation MyCustomModule
	RCT_EXPORT_MODULE();
	// 通过这个宏就能暴露原生接口
	RCT_EXPORT_METHOD(processString:(NSString *)input callback:(RCTResponseSenderBlock)callback)
	{
		callback(@[[input stringByReplacingOccurrencesOfString:@"Goodbye" withString:@"Hello"];]]);
	}
	@end
	
	// JavaScript  
	var React = require('react-native');
	var { NativeModules, Text } = React;
	
	var Message = React.createClass({	
		render: function() {
			getInitialState() {
				return { text: 'Goodbye World.' };
			},
		// 在此处调用了原生的API	
		componentDidMount() {
			NativeModules.MyCustomModule.processString(this.state.text, (text) => {
				this.setState({text});
				});
			},
		
			return (
				<Text>{this.state.text}</Text>
			);
		},
	});	
	
	
	// react可以重用原生UI，方法是在RCTViewManager的子类里实现-(UIView *)view。需要调用时用RCT_EXPORT_VIEW_PROPERTY暴露。
	
	//  OC代码
	#import "RCTViewManager.h"
	@interface MyCustomViewManager : RCTViewManager
	@end
	// 调用此view
	@implementation MyCustomViewManager
		- (UIView *)view
		{
			return [[MyCustomView alloc] init];
		}
		// 向JS暴露属性
		RCT_EXPORT_VIEW_PROPERTY(myCustomProperty);
	@end	
	
	// JS代码
	// 生成一个模型
	module.exports = createReactIOSNativeComponentClass({
		validAttributes: { myCustomProperty: true },
		uiViewClassName: 'MyCustomView',
	});
	
	
	*Java平台（Java platform）。是一套工具，包括Java虚拟机和Java Core。可以在任意操作系统上为Java程序提供统一的编程接口
	
	*.NET平台，（.NET platform）。是一套工具，包括了CLR和framework类库。
	可以为任意操作系统上的纯.NET程序提供统一的编程接口。
	
	*生态环境	影响生物生活和生产活动的各种力量（物质，能量，作用）的总和
	
	*模型	用材料或虚拟来表现形态和结构。(重点是表现)
	
	
	// 如何渲染图片
	1、在index.XXX.js里
		
	【JAVA开发环境设置】
	 *jdk(Java Develop Kit)
	 是专供Java用的开发环境，所有的java程序都要在它上面构建。包括了一组API		
		
	 *Java SDK 
	  相对宽泛的概念。是辅助开发Java的相关文档、范例和工具的集合
	 
	 *开发服务器
	 	"服务器"是根据设备功能来划分时对设备的称呼.能给其他设备提供服务的,就是服务器.开发服务器就是提供开发程序,编译程序服务的机器.而目标机则是部署,运行程序的机器.
	 	
	 *配置java开发环境
	    这个真心很麻烦
	    ~首先要下载jdk
	    地址:http://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html
	    oracle提供的java开发专用库
	    
	    ~然后要下载SDK
	    用android SDK Manager
	    因为我国的特殊国情,需要使用代理
	    镜像:mirrors.neusoft.edu.cn  
	    端口:80
	    
	    按照环境配置的要求下载各种SDK
	    
	    ~然后要配置路径,供java程序找到对应的sdk
	    Mac系统中:
	    cd ~  (~表示用户目录  /Users/用户名 )
	    然后在 .bash_profile文件里配置 ANDROID_HOME环境变量(.表示文件隐藏)
	    
	    顺便介绍配置的方法
	    sudo vi .bash_profile
	    然后粘贴
	    
	    vi 在打开时默认为命令行模式,按i进入编辑模式
	    返回命令行模式时,按  shift + :
	    wq是保存+退出
	    
	    ~在window系统下
	      在环境变量-> path变量里添加.详情免
	      
	      
	  *Android真机调试
	  	~开启手机的调试模式
	  	
	  	~手机USB连接Mac机
	    
	    ~用adb devices查看设备,最好当前只有一台设备连到Mac机(模拟器也最好关掉)
	    
	    ~cd 到工程的根目录 ,react-native run-android
	    
	    ~开启目标机的悬浮窗设置 设置 -> 其他应用管理 -> 选中app -> app操作菜单之权限管理 -> "显示悬浮窗"设置为true
	    
	    ~摇晃手机,在浮现的菜单里选"Dev Settings" -> Debugging -> 在弹出的对话框里填上开发服务器的ip和端口.返回,重启app,即可正确显示js
	    
	    
	    然后摇晃手机,在浮现的菜单里点选 "Debug in Chrome",在弹出的chrome里选择 列表 -> 其他工具 -> 开发者工具,即可在弹出窗体的debuggerWorker.js里,用断点调试.
	    
	 *第一个react-native程序的感想
	 	1. 由数据,界面布局,样式表(还有没出场的JS)组成
	 	2. 写在标签的<>里的都是属性设置,比如 <Text style = {style.font} />
	 	3. js包含了执行体和数据 
	 	
	
	 2016年04月11日09:43:18
	 
	 	*官方对react-native技术的解释
	 		.js里必备的render()方法,用于展示样式
	 		可接受参数,访问参数的方式是 this.prps.xxx
	 		// 定义
	 		var Hello = React.createClass({
	 			render(){
	 				return <div> Hello {this.props.name}</div>;
	 			}
	 		}
	 		);	
	 		
	 		// 调用
	 		ReactDOM.render(<Hello name="John" />, mountNode);
	 		
	 	  或者以组件的形式,调用内部变量
	 	  var Timer = React.createClass(
	 	    // 不定义就直接生成变量?
	 	  	getInitialState(){
	 	  		return {secondsElapsed:0};
	 	  	},
	 	  	// 
	 	  	tick(){
	 	  	  this.setSate({secondsElapsed:this.state.secondsElapsed + 1});
	 	  	},
	 	  	componentDidMount(){
	 	  		this.interval = setInterval(this.tick, 1000);
	 	  	},
	 	  	componentWillUnmount(){
	 	  		clearInterval(this.interval);
	 	  	},
	 	  	render(){
	 	  		return(
	 	  			<div> Seconds Elapsed: {this.state.secondsElapsed} </div>
	 	  		);
	 	  	}
	 	  );
	 	  
	 	  ReactDOM.render( <Timer /> , mountNode);
	 	  
	 	2016年04月11日10:00:55
	 	
	 	2016年04月11日11:19:23
	 	#react native 语法基础#
	 		用内部变量实现一个列表.
	 		事件句柄内嵌,用代理来实现
	 		
	 		js是弱类型的语言,无类型
	 		
	 		var TodoList = React.createClass(
	 			render(){
	 			    // 需要被嵌套的列表
	 				var createItem = function(item){
	 					return <li  key={item.id}>{item.text}</li>
	 				};
	 				return <ul> {this.props.items.map(createItem)} </ul>;
	 			}	 		
	 		);
	 		
	 	2016年04月11日12:41:46
	 	
	 	
		#jedit使用技巧#
			一般是中文解码失败,出现i/o load Error提示窗,解决办法是File-> Reload With Encoding -> 改用GBK编码
			
			常用的设置一般都可在Utilities -> Global Options里找到
			
		#c++知识#	
			变量的特性:
				链接性(能否用于其他编译单元.如能,称为外部变量)
				作用域(在代码块,编译单元还是整个工程里可见)
				持续性(存在于内存里的时间段 自动/静态)
			
				
		2016年04月11日13:09:07
			#react native 语法基础#
				var TodoApp = React.createClass({
				// 自定义的,在state集合里的变量
  				getInitialState: function() {
  				  return {items: [], text: ''};
 				 },
 				 // 响应事件,给属性赋值
  				onChange: function(e) {
    				this.setState({text: e.target.value});
  				},
  				// 响应事件,输入区的点击事件
 				handleSubmit: function(e) {
 				   e.preventDefault();
 				   // 新增
  				  var nextItems = this.state.items.concat([{text: this.state.text, id: Date.now()}]);
  				  var nextText = '';
  				  // 刷新两个state的值
  				  this.setState({items: nextItems, text: nextText});
  				},
  				// 还是样式,不过有点区别
  				render: function() {
  				  return (
  				    <div>
  				      <h3>TODO</h3>
  				      // 列表项
  				      <TodoList items={this.state.items} />
  				      // 输入区,form直接绑定按钮的提交功能?
   				      <form onSubmit={this.handleSubmit}>
   				       // input直接关联属性,在onchange里设置setState,从而触发重新渲染
   				       <input onChange={this.onChange} value={this.state.text} />
   				       // 按钮不用添加事件?
   				       <button>{'Add #' + (this.state.items.length + 1)}</button>
    				  </form>
    				</div>
  				 );
 				 }
				});

				ReactDOM.render(<TodoApp />, mountNode);
				
		2016年04月11日13:48:00
		
		2016年04月11日13:56:28
			#react native 语法基础#
				调用this.setState()时,会再次触发render
				2016年04月11日14:49:54
				类调用的方法一般都是类方法,用this.function来调用
				例如
				class Hello extends component{
				render(){
					return this.renderLoadingView();
				}
				
				renderLoadingView(){
					return(
					<View>
						<Text>在加载~~~</Text>
					</View>
					);}	
				}
				
			样式用
				var style = StyleSheet.create(
					{
						container:{
							flex:1,
							
						},	
					
					
					});
				放在js文件的最后,有三个好处
				1.不可更改
				2.不可见
				3.只要加载一次,不用每次render都加载
				
				数据的表示方式是:{ 数据内容 }
				
				2016年04月11日15:35:26
					#react native 语法基础#
						加载图片时的注意点
						1. 加载本地图片时,需要不同尺寸,相同内容的图片,以适应不同的屏幕
						2. 加载网络图片,需要手动指定图片尺寸
							<Image source ={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}
							style = {{width: 400, height: 400}}/>
							另外要注意,这里的uri:xxx指定了一个uri属性为xxx的对象
						
						3. 图片性能					
							名词解释:掉帧
								UI丢失应该加载的图片
								
							FPS:帧率
								每秒应该展现的图片数,标准为60,也就是每16ms需要生成一张图片,倘若开发者和UI系统无法在此时间内生成一张图片,则界面会卡顿.
							react的运行机制是:由JS运行业务逻辑,然后将数据更新到原生界面.
							在push新页时,js需要绘制所有组件,所以必然会占用时间,引起页面卡顿

							
					2016年04月11日16:34:51					
						#react native 语法基础#
							DOM:可用于管理html和XML文件里的元素,包括增删改查
							
						重要:this.prop用于传递数据(包括文件内和文件之间)
						   this.state用于刷新视图

						   
					2016年04月12日10:50:46
						#web布局基础#
							css文本渲染样式时针对的是class
							.flex-container{
								………………
								………………
							}							
							<Span class="flex-container" ></Span>
							
							
							style渲染样式时针对的是标签
							<head>
								<style type="text/css">
										body {background-color: red}
										p {margin-left: 20px}
								</style>
							</head>							
							<span class="flex-container"> 
								<span class="flex-item">1</span>
								<span class="flex-item">5</span>
							</span>
							
							
						#react技术#
							原生特性
								js可以写原生代码,也可以访问平台.我们的第一步是封装原生模块供react使用
								
								封装的第一步:
									让原生代码成为RCTBridgeModule的协议,比如这样
									@interface CalendarManager : NSObject <RCTBridgeModule>
									@end	
								
								第二步,在@implement @end里,添加协议的实现
								
									RCT_EXPORT_MODULE();
								
								第三步,给要导出的方法添加RCT_EXPORT_METHOD()宏
									RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
									被导出的方法的返回值必须是void
									
								第四步 在js里调用
									var CalendarManager = require('react-native').NativeModules.CalendarManager;
									CalendarManager.addEvent('name', 'Shanghai');
								
								第五步  有回调时
									RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
									{
									    // 获取值,是一个数组
										NSArray *events = 
										// 传值
										callback( events);
									}
									
									在js里
									var CalendarManager = require('react-native').NativeModules.CalendarManager;
									CalendarManager.findEvent((Events)=> {
										
									})