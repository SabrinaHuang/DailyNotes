	小结redux用法

----------------Action----------------
action 一个对象，用于标志行为
	const increaseAction = { type:'increase' }

----------------Reducers----------------
	#import {increaseAction} from './Action';


	function filter( state= {count:0} , action){
		const _count = state.count;

		switch( action.type ){
			case 'increase':
				return {count:_count + 1}
			default:
				return state;
		}
	}


----------------Store----------------
	const store = createStore(filter)


 在实际调用时，store.dispatch(increaseAction)


----------------RN部分----------------
	
	class Counter extends Component(
		render(){
			const {value,} = this.props;
			<div>
				<p>{}</p>
			</div>
		}
	)

	Counter.propTypes = 

	
	function todos(state=[],action){
	// 返回一个数组，数组里添加一个对象
	switch(action.type){
		case 'ADD_TODO':
			return [
			...state,{
			text:action.text,
			completed:false
			}];

		case 'COMPLETE_TODO':	
			return [
				...state.slice(0,action.index),
				Object.assign({}， state[action.index],{completed:true}),
				...state.slice(0,action.index + 1),
			];

		default:
			return state;	
	}}

	// 需要导入映射表Reducers和映射表对应的驱动store
	import { combineReducers, createStore  } from 'redux';	

	let reducer = combineReducers({visibilityFilter, todos });
	let store = createStore();


	function counter( state = 0, action ){
		switch(action.type){
			case 'INCREMENT':
				return state + 1;
			case 'DECREMENT':
				return state - 1;
			default:
				return state;
		}
	}



	Props通常用于指定组件的属性
	
	const defaultProps = {
		size:'normal',
		type:'btn'
	};

	class MapPart extends Component(
		<div>
			<button defaultProps=defaultProps >点击就送</button>
		</div>
	)

	*web前端开发中，ES5,ES6,ES7都是一套语法规则

	*props作为组件的属性，应当只被赋值一次，不该重复修改
	正确样例
		var component = <Component foo={x} bar={y}  />;

	错误样例	
		var component = <Component />;
		component.props.foo = x;
		component.props.bar = y;


	... 对props来说表示展开语法，将里面的键值对全都展开
	var props={foo:'default'};
	<Component  {...props} foo:'default_1' />


	props还有解构赋值的属性，
	{a,b,rest} = this.props时，a,b会获取props里名为a,b的对象的值，而rest会获取余下的值。


	当组件不需要state时，可用如下方式取代render 自定义组件
	const Button = (props)=>{
		const {children, onClick} = props

		return(
			<TouchableOpacity onPress={onClick} >
				<Text>{children}</Text>
			</TouchableOpacity>
		)
	}
	export default Button


	*Action的一种新写法，很独特的感觉,据说优点是可以自定义参数，还可以防止写错

	---------------------counterActions---------------------
		export const increment = (id) => {
			return{
				type:INCREMENT,
				payload:{
					id
				}
			}
		}		

		导出到RN时的格式
			// 导入这些action动作们
			import * as counterActions from '../actions/'

			class counterApp extends Component{
				const {state, actions} = this.props
				return(
					<Counter
						counter={state.count},
						{...actions}/>
				)
			}

			export default connect( (state)=>{
				return ( {state:state.counter} )
			},
			(dispatch) => ({
				actions:bindActionCreators(counterActions ,dispatch )
			})
			)( counterApp );

			这connect方法的作用是关联store到组件的props


	*引用对象/变量的方法  action的其他写法
		// 这语法很像DCL语言
		import * as types from  './actionTypes';

		export function increment(){
			return{
				type:types.INCREMENT
			}
		}


	connect可将store关联到组件的props
	试着分析说明

	在 counterAction.js里
		export function increment() {
  		return {
    		type: types.INCREMENT
  		};
		}

		export function decrement() {
		  return {
 		   type: types.DECREMENT
  		};
		}


	在counter.js里
		export default class Counter extends Component {
  constructor(props) {
    super(props);
  }

  render() {
    const { counter, increment, decrement } = this.props;

    return (
      <View >
        <Text>{counter}</Text>
        <TouchableOpacity onPress={increment} style={styles.button}>
          <Text>up</Text>
        </TouchableOpacity>
        <TouchableOpacity onPress={decrement} style={styles.button}>
          <Text>down</Text>
        </TouchableOpacity>
      </View>
    );
  }

	在counterApp.js里
	将reducer扣出来
	import * as counterActions from '../actions/counterActions';

	class CounterApp extends Component(
		render(){
			const {state,action} = this.props;
			return (
				// 这将传给counter
				<Counter state = {state.count} {...actions} />
			)
		}
	)


	然后要将action绑定到counter上
	export default connect(state =>{
		console.log(state.counter)
  		return ({
      		state: state.counter
    	});} ,
  		(dispatch) => ({
    			actions: bindActionCreators(counterActions, dispatch)
  		})
	)(CounterApp);

	这分层分得老细了

	有counter,counterApp


	actions - counterAction.js // state -> action 的映射
	component - counter.js  // html模板	
	containers - counterApp.js 
		关键是在counter里，定义
		<Text>{counter}</Text>
		<TouchableOpacity onPress={increment} />

		然后定义counterAction
		import  * as types from 'actions'

		export function increase(){
			return{
				types:types.INCREMENT;
			}
		}


	const initialState={
		count:0,
	}

	reducer.js
		export default function counter( state=initialState, action={} )	


	在app.js里 
	<Provider store={store}>

	</Provider> 

	*jsx是将HTML模板直接嵌入JS的一种语法

	AppRegistry.registerComponent('Counter', () => App); 这句的作用是将名为Counter的Component注册到名为App的组件上


	*完全摒弃class写法的组件生成(在不涉及state的情况下)
		const Button= (props)=>{
			const {children, onClick} = props,
			return(
				<Touch onPress={onClick}>
					<Text>{children}</Text>
				</Touch>
			)
		}

		ES7中Button.PropTypes={
			children:,isRequired,
			onClick:,isRequired,
		}


		ES7中函数的写法为：
			export const increment = (id) => {
				return {
					type:INCREMENT,
					payload:{
						id
					}
				}
			}	


		reduce的样式为
			export default handleActions({
				[]

			})	


		*store和reducer的关系
			store是系体，将state和action传给reducer

			store会获取state和action(都是对象)

			let prevState = {
				visibleTodoFilter: 'SHOW_ALL',
				todos:[{
					text: 'Read the docs',
					complete:false,
				}]
			}

			let action = {
				type: '',
				text: '',
			}

			通过reducer和action更新state
			let nextState = todoApp(prevState, action )

			
			




