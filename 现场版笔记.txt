			
		/* ??待验证 */	
	// 	react 本身融入 JS的API，比如XMLHttpRequest,navigator.geolocation等
	var React = require('react-native');
	var { Text } = React;
		*指定了三个对象
	var GeoInfo = React.createClass({
		getInitialState: function() {
		return { position: 'unknown' };
	},	
	
	componentDidMount: function() {
		navigator.geolocation.getCurrentPosition(
			(position) => this.setState({position}),
			(error) => console.error(error)
		);
	},
	
	render: function() {
	   return (
		  <Text>
			Position: {JSON.stringify(this.state.position)}
		  </Text>
		);
	   },
	});
	
	
	
	// react可以重用原生UI，方法是在RCTViewManager的子类里实现-(UIView *)view。需要调用时用RCT_EXPORT_VIEW_PROPERTY暴露。
	/* 研究重点 */
	//  OC代码
	#import "RCTViewManager.h"
	@interface MyCustomViewManager : RCTViewManager
	@end
	// 调用此view
	@implementation MyCustomViewManager
		- (UIView *)view
		{
			return [[MyCustomView alloc] init];
		}
		// 向JS暴露属性
		RCT_EXPORT_VIEW_PROPERTY(myCustomProperty);
	@end	
	
	// JS代码
	// 生成一个模型
	module.exports = createReactIOSNativeComponentClass({
		validAttributes: { myCustomProperty: true },
		uiViewClassName: 'MyCustomView',
	});

	
	在JS里,nav被做成一个容器,控制页面的压栈和弹出.导航条的样式需要自行创建
		对navigator来
			写定义的地方,navigator控件在
				initialRoute方法里,存了当前活动页面的Route信息,包括name和component
				
				在renderScene回调里,
					renderScene={(route,navigatr)=>{………………}}里的route就包含这两个值,而navigator就是导航栏对象
				要渲染页面时,用route里的参数,并将navigator也传给新渲染的页面	
				
					let Component = route.component;
					<Component {...route.params} navigator={navigator} />
		
					
			在调用时,从props里获取navigator,用此nav来push
				const {navigator} = this.props;
				if(navigator){
					navigator.push(
						name:'secondComponent',
						component:SecondComponent,
					)
				}

				item is props 
				then 
					render时，扣取这个props作为route.
					props不过是个中介罢了。
				
				
			将原生View导出的方法
				
			对被调界面Component
			
			step2:
			需要建导出的js 例如demoView.js
			var { requireNativeComponent } = require('react-native');
			
			// 定义输出,名称是之前的.m去掉词尾的manage
			modle.exports = requireNativeComponent( 'RCTview',null );
			
			
			step3:
				在js里调用此控件
				import  RCTview from './demoView'
				
				<RCTview />


				在JS里，字符串以 '' 包裹  拼接时可直接用+号

				Promise对象代表着一个还未完成，但预期将来会完成的操作。是代理。
				调用的顺序
					Promise  -> then() // 确定状态 fulfill或reject 返回值是promise 所以可以链式调用
					Promise -> .then .catch()	


				
				

