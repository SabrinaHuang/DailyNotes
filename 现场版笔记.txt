
	
	function todos(state=[],action){
	// 返回一个数组，数组里添加一个对象
	switch(action.type){
		case 'ADD_TODO':
			retrn [
			...state,{
			text:action.text,
			completed:false
			}];

		case 'COMPLETE_TODO':	
			return [
				...state.slice(0,action.index),
				Object.assign({}， state[action.index],{completed:true}),
				...state.slice(0,action.index + 1),
			];

		default:
			return state;	
	}}

	// 需要导入映射表Reducers和映射表对应的驱动store
	import { combineReducers, createStore  } from 'redux';	

	let reducer = combineReducers({visibilityFilter, todos });
	let store = createStore();


	function counter( state = 0, action ){
		switch(action.type){
			case 'INCREMENT':
				return state + 1;
			case 'DECREMENT':
				return state - 1;
			default:
				return state;


	props还有解构赋值的属性，


	在JS中注释块时，除了 /**/之外，还要用{}， // 同理，不过//对应的{}要分行

	react-native和react的差别在于前者用的是JSX语法，不能用html里的组件。只能用类似的组件，比如View对应css里的div, text对应css里的span

	
	受控组件，其显示需要通过自己的state来刷新
	比如
		picker

		通过其selectedValue驱动组件
		而selectedValue要绑定到 this.state.someVal
		this.state.someVal通过onValueChange的回调刷新

		这些组件的value需要绑定到某个变量上，随变量而变

	比如
		textInput 有value属性，绑定到state上
		然后 在onChangeText里，(val) => this.setState(  );


	模型可以描述实体的定义，实体的操作，实体操作的结果，实体的管理限制。
	比如表就是关系模型的实例



	react-native的真机调试
		在RCTWebSocketExecutor里，将setUp方法里的URL指定为开发服务器的地址
		在appDelegate里，将App对应的localhost指定为开发服务器

		重新启动项目，摇晃调试机，在弹出的菜单中选择JS Remotely Debugging
		在chrome浏览器里，三横线菜单-> more Tools -> Developer Tools

		不调试时摇晃出菜单，选 disable remote load		 


	JS是典型的层级对象结构，以<Text> Entitya + Entityb + Entityc </Text> 为例，会将 a b c 当做对象，以对象串联的方式连接。如果在其中用 + 等符号，因为对象本身没有定义+操作，所以会将 + 当做对象来处理， 返回的结果是 "Entitya.value + Entityb.value + Entityc.value" 这样的字符串


	JS里的大小写敏感
		一定要注意这点。因为JS非编译性语言，没有语法检查功能和标志检查功能，写错标志也不会提示。

	没有<br/>或者\n可以折行，需要分行时，用text标签	



	当组件的props（一般都是些框架性的配置）变化时，会触发
	1、 componentWillRecProps
			将要接收
	2、 shouldCompUpdate()
			接收前夕
	3、compWillUpdate()
			将要渲染
	4、render()
			渲染

	

	RN VS. reactNative  抽象层相同，但有差异，前者用于移动端开发，后者用于web开发

	package.json里，逗号有严格的规范，dependencies 里最后一项值不应以逗号结尾。


	js里，需要和业务无关的utils，用于配置
		比如
		1、尺寸配置  pixel,width,height

		2、网络请求，包括封装好的post
			post(url,data,callback)
			和
			host,login,getUser,updateUser,deleteUser,createUser等接口的地址

		3、以首页的开发为例
			设置



	引用工程时，
	1、 到node_modules（提供node工具），调用Library里特定工程的xcodeProj，例如address_book.xcodeProj

	2、 在此xcodeProj里，从build Phases里添加静态库



	props可通过父控件传给子控件，比如 <CustomView  customID1 = value1 customID2 = value2  />

	例如：
		在CustomView的处理中，可通过 this.props.customID1 获取对象
	customID1的值也可以是方法， 比如 (value) => { this.setState({state1:value} ) }  (这里value如果是单值，就写成单值。如果是对象，就要展开为{...value})


	当父控件传给子控件的prop改变时，往往需要通过组件的生命周期方法来相应地更新子控件

	例如
	<View style={a,b,c}>
		<CustomComponent {...this.state}/>
	</View>

	当view的state改变时
	在CustomComponent.js里,props改变，不能触发事件

	于是在生命周期事件，setState,从而触发重渲染
		componentWillReceiveProps(){
			this.setState({});

		}


	props,state,variable在调用时，形式不同。props，state都要加this.的前缀，以表示引用，
	var因为是全局变量，所以直接通过名称调用即可
		

	生成列表时，
	0、 需要数据源
			var data = [{a,b,c},{a,b,c},{a,b,c},{a,b,c},{a,b,c}];
	1、 实现一个数组
			var items = [];
	2、 将数据循环填入
			for( var i in data )		
			{
				let item = (
					<View>
						<Text>{items[i].value}</Text>
					</View>
				);

				items.push(item);
			}	


	3、将数组放入组件来渲染
			<View>
				{items}
			</View>		



	导入和导出
		export class customClassA{……………………}  // 此处没有default关键词

		import {customClassA} from // 需要用{}将其囊括起来，否则会导入默认的组件		


	this.setState is not a function ,出现本问题往往由于在调用时未bind到this，导致动作没有发起对象。	

	connect函数，第一个参数将state的值（此state来自reducer方法里的state）绑定到props上


	源文件要写成 {uri;'https://weibo.com/vczero'}



	网络请求可以封装
		需要url, data和回调

		url是fetch方法的必填参数，data是fetch的第二个参数，是optional的。callback必填，是fetch的回调

		封装时
			var fetchOptions = {
				method:'POST',
				headers:{

				},
				body: JSON.stringify(data)
			}

			fetch( url,fetchOptions )
			.then( (response) => response.text() ) 
			.then((responseText)=>{
				callback(JSON.parse(responseText));
			});

			
			-----GET方式-----
			在url里，可以直接写上请求
			'url?response_type=code'
			+ '&state=1234'
			+ '&view=wap'
			+ ………………

			这叫get方式

			-----POST方式-----
			而在post方式里，会创建表单实体，并将实体作为option传出去

			List param = new ArrayList();
			param.add(obj1);
			param.add(obj2);
			Entity  entity1 = EntityWithParam(Param);

			// 将param传给post请求实例
			Post.setEntity(entity1);
			HttpResponse.execute(Post);



		










		

