			
		/* ??待验证 */	
	// 	react 本身融入 JS的API，比如XMLHttpRequest,navigator.geolocation等
	var React = require('react-native');
	var { Text } = React;
		*指定了三个对象
	var GeoInfo = React.createClass({
		getInitialState: function() {
		return { position: 'unknown' };
	},	
	
	componentDidMount: function() {
		navigator.geolocation.getCurrentPosition(
			(position) => this.setState({position}),
			(error) => console.error(error)
		);
	},
	
	render: function() {
	   return (
		  <Text>
			Position: {JSON.stringify(this.state.position)}
		  </Text>
		);
	   },
	});
	
	
	
	// react可以重用原生UI，方法是在RCTViewManager的子类里实现-(UIView *)view。需要调用时用RCT_EXPORT_VIEW_PROPERTY暴露。
	/* 研究重点 */
	//  OC代码
	#import "RCTViewManager.h"
	@interface MyCustomViewManager : RCTViewManager
	@end
	// 调用此view
	@implementation MyCustomViewManager
		- (UIView *)view
		{
			return [[MyCustomView alloc] init];
		}
		// 向JS暴露属性
		RCT_EXPORT_VIEW_PROPERTY(myCustomProperty);
	@end	
	
	// JS代码
	// 生成一个模型
	module.exports = createReactIOSNativeComponentClass({
		validAttributes: { myCustomProperty: true },
		uiViewClassName: 'MyCustomView',
	});

	
	在JS里,nav被做成一个容器,控制页面的压栈和弹出.导航条的样式需要自行创建
		对navigator来
			写定义的地方,navigator控件在
				initialRoute方法里,存了当前活动页面的Route信息,包括name和component
				
				在renderScene回调里,
					renderScene={(route,navigatr)=>{………………}}里的route就包含这两个值,而navigator就是导航栏对象
				要渲染页面时,用route里的参数,并将navigator也传给新渲染的页面	
				
					let Component = route.component;
					<Component {...route.params} navigator={navigator} />
		
					
			在调用时,从props里获取navigator,用此nav来push
				const {navigator} = this.props;
				if(navigator){
					navigator.push(
						name:'secondComponent',
						component:SecondComponent,
					)
				}

				item is props 
				then 
					render时，扣取这个props作为route.
					props不过是个中介罢了。
				
				
			将原生View导出的方法
				
			对被调界面Component
			
			step2:
			需要建导出的js 例如demoView.js
			var { requireNativeComponent } = require('react-native');
			
			// 定义输出,名称是之前的.m去掉词尾的manage
			modle.exports = requireNativeComponent( 'RCTview',null );
			
			
			step3:
				在js里调用此控件
				import  RCTview from './demoView'
				
				<RCTview />


				在JS里，字符串以 '' 包裹  拼接时可直接用+号

				Promise对象代表着一个还未完成，但预期将来会完成的操作。是代理。
				调用的顺序
					Promise  -> then() // 确定状态 fulfill或reject 返回值是promise 所以可以链式调用
					Promise -> .then .catch()	


			#委托模式#
				基本思想是通用框架调用业务实体

				实现
					-------------------协议-------------------
					XXXdelegate.h
					需要协议作用域
					@protocol
						@required
						-(void) sleep;
						-(void) work;
						-(void) eat;						
					@end



					-------------------在实现协议的类里-------------------
					.h
					@interface XXXobj:NSObject<XXXDelegate>
					@end

					.m
					-init
					{
						Frame *frame = [Frame new];
						frame.delegate = self;
						frame.start;	
					}

					-(void) sleep;
					-(void) work;
					-(void) eat;	
					-------------------在实现协议的类里-------------------


					-------------------在调用协议的类里-------------------
					Frame.h 
					#include XXXdelegate.h
					@interface  XXX:NSObject

					// 自己的变量
					{
						var1;
						var2;
					}

					// 对类的引用
					@property <XXXDelegate> delegate
					//自己的方法
					-method1;
					-method2;
					@end

					Frame.m
					-method1
					{
						[self.delegate sleep];

					}	
					-------------------在调用协议的类里-------------------

					例如，实现了textFieldDelegate的 viewController。textField控件会调用
					其中实现的委托

					viewControl 关联到 textField 
					@IBOutlet someTextField

					someTextField.delegate = self;


				

				JS调原生UI
					--------------------原生UI--------------------
						.m
						@interface RCTxxxManager:RCTViewManager
						@end

						@implement RCTxxxManager
							-(UIView *)view
							{
								……………………
								return view;
							}

						@end
					--------------------原生UI--------------------

					--------------------导出原生的文件--------------------
						.js
						import React,{
    								DeviceEventEmitter,
    								requireNativeComponent,
    								PropTypes
    					} from 'react-native'


    					// 如此即可导出组件，标签名为RCTXXX
						module.exports = requireNativeComponent('RCTXXX',null);

					--------------------导出原生的文件--------------------


				#require语法#
						require('XXX'); 用于加载模块到js文件，其中XXX可被视为文件或目录

					import React,{
						AppRegistry,
						Text,
					}from 'react-native';	

					React是容器，是集合，而AppRegistry，Text是集合里的元素


				EventEmitter可在当前组件里设置监听事件
				EventEmitter.addListerner('ZBarCodeRead',this._onRead);

				第一个参数ZBarCodeRead是另一个组件里的方法
				第二个参数_onRead是本组件的方法，第二个参数指定的方法监听第一个方法






