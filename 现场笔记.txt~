
			
		/* 02待验证 */	
	// 	react 本身融入 JS的API，比如XMLHttpRequest,navigator.geolocation等
	var React = require('react-native');
	var { Text } = React;
		*指定了三个对象
	var GeoInfo = React.createClass({
		getInitialState: function() {
		return { position: 'unknown' };
	},	
	
	componentDidMount: function() {
		navigator.geolocation.getCurrentPosition(
			(position) => this.setState({position}),
			(error) => console.error(error)
		);
	},
	
	render: function() {
	   return (
		  <Text>
			Position: {JSON.stringify(this.state.position)}
		  </Text>
		);
	   },
	});
	
	
	//  react可以重用原生代码。做法是包装对JS可用的功能，并用RCT_EXPORT_MODULE() 显式导出	
	// Objective-C,封装了原有的类，让JS可通过RCT_EXPORT_METHOD
	#import "RCTBridgeModule.h"
	@interface MyCustomModule : NSObject <RCTBridgeModule>
	@end

	@implementation MyCustomModule
	RCT_EXPORT_MODULE();
	// 通过这个宏就能暴露原生接口
	RCT_EXPORT_METHOD(processString:(NSString *)input callback:(RCTResponseSenderBlock)callback)
	{
		callback(@[[input stringByReplacingOccurrencesOfString:@"Goodbye" withString:@"Hello"];]]);
	}
	@end
	
	// JavaScript  
	var React = require('react-native');
	var { NativeModules, Text } = React;
	
	var Message = React.createClass({	
		render: function() {
			getInitialState() {
				return { text: 'Goodbye World.' };
			},
		// 在此处调用了原生的API	
		componentDidMount() {
			NativeModules.MyCustomModule.processString(this.state.text, (text) => {
				this.setState({text});
				});
			},
		
			return (
				<Text>{this.state.text}</Text>
			);
		},
	});	
	
	
	// react可以重用原生UI，方法是在RCTViewManager的子类里实现-(UIView *)view。需要调用时用RCT_EXPORT_VIEW_PROPERTY暴露。
	
	//  OC代码
	#import "RCTViewManager.h"
	@interface MyCustomViewManager : RCTViewManager
	@end
	// 调用此view
	@implementation MyCustomViewManager
		- (UIView *)view
		{
			return [[MyCustomView alloc] init];
		}
		// 向JS暴露属性
		RCT_EXPORT_VIEW_PROPERTY(myCustomProperty);
	@end	
	
	// JS代码
	// 生成一个模型
	module.exports = createReactIOSNativeComponentClass({
		validAttributes: { myCustomProperty: true },
		uiViewClassName: 'MyCustomView',
	});

	
	*生态环境	影响生物生活和生产活动的各种力量（物质，能量，作用）的总和
	
	*模型	用材料或虚拟来表现形态和结构。(重点是表现)
	
	
	// 如何渲染图片
	1、在index.XXX.js里

	      
	      
	  *Android真机调试
	  	~开启手机的调试模式
	  	
	  	~手机USB连接Mac机
	    
	    ~用adb devices查看设备,最好当前只有一台设备连到Mac机(模拟器也最好关掉)
	    
	    ~cd 到工程的根目录 ,react-native run-android
	    
	    ~开启目标机的悬浮窗设置 设置 -> 其他应用管理 -> 选中app -> app操作菜单之权限管理 -> "显示悬浮窗"设置为true
	    
	    ~摇晃手机,在浮现的菜单里选"Dev Settings" -> Debugging -> 在弹出的对话框里填上开发服务器的ip和端口.返回,重启app,即可正确显示js
	    
	    
	    然后摇晃手机,在浮现的菜单里点选 "Debug in Chrome",在弹出的chrome里选择 列表 -> 其他工具 -> 开发者工具,即可在弹出窗体的debuggerWorker.js里,用断点调试.
	    
	 *第一个react-native程序的感想
	 	1. 由数据,界面布局,样式表(还有没出场的JS)组成
	 	2. 写在标签的<>里的都是属性设置,比如 <Text style = {style.font} />
	 	3. js包含了执行体和数据 
	 	
	
	 2016年04月11日09:43:18
	 
	 	*官方对react-native技术的解释
	 		.js里必备的render()方法,用于展示样式
	 		可接受参数,访问参数的方式是 this.prps.xxx
	 		// 定义
	 		var Hello = React.createClass({
	 			render(){
	 				return <div> Hello {this.props.name}</div>;
	 			}
	 		}
	 		);	
	 		
	 		// 调用
	 		ReactDOM.render(<Hello name="John" />, mountNode);
	 		
	 	  或者以组件的形式,调用内部变量
	 	  var Timer = React.createClass(
	 	    // 不定义就直接生成变量?
	 	  	getInitialState(){
	 	  		return {secondsElapsed:0};
	 	  	},
	 	  	// 
	 	  	tick(){
	 	  	  this.setSate({secondsElapsed:this.state.secondsElapsed + 1});
	 	  	},
	 	  	componentDidMount(){
	 	  		this.interval = setInterval(this.tick, 1000);
	 	  	},
	 	  	componentWillUnmount(){
	 	  		clearInterval(this.interval);
	 	  	},
	 	  	render(){
	 	  		return(
	 	  			<div> Seconds Elapsed: {this.state.secondsElapsed} </div>
	 	  		);
	 	  	}
	 	  );
	 	  
	 	  ReactDOM.render( <Timer /> , mountNode);
	 	  
	 	2016年04月11日10:00:55
	 	
	 	2016年04月11日11:19:23
	 	#react native 语法基础#
	 		用内部变量实现一个列表.
	 		事件句柄内嵌,用代理来实现
	 		
	 		js是弱类型的语言,无类型
	 		
	 		var TodoList = React.createClass(
	 			render(){
	 			    // 需要被嵌套的列表
	 				var createItem = function(item){
	 					return <li  key={item.id}>{item.text}</li>
	 				};
	 				return <ul> {this.props.items.map(createItem)} </ul>;
	 			}	 		
	 		);
	 		
	 	2016年04月11日12:41:46
	 	
	 	
		#jedit使用技巧#
			一般是中文解码失败,出现i/o load Error提示窗,解决办法是File-> Reload With Encoding -> 改用GBK编码
			
			常用的设置一般都可在Utilities -> Global Options里找到
			
		#c++知识#	
			变量的特性:
				链接性(能否用于其他编译单元.如能,称为外部变量)
				作用域(在代码块,编译单元还是整个工程里可见)
				持续性(存在于内存里的时间段 自动/静态)
			
				
		2016年04月11日13:09:07
			#react native 语法基础#
				var TodoApp = React.createClass({
				// 自定义的,在state集合里的变量
  				getInitialState: function() {
  				  return {items: [], text: ''};
 				 },
 				 // 响应事件,给属性赋值
  				onChange: function(e) {
    				this.setState({text: e.target.value});
  				},
  				// 响应事件,输入区的点击事件
 				handleSubmit: function(e) {
 				   e.preventDefault();
 				   // 新增
  				  var nextItems = this.state.items.concat([{text: this.state.text, id: Date.now()}]);
  				  var nextText = '';
  				  // 刷新两个state的值
  				  this.setState({items: nextItems, text: nextText});
  				},
  				// 还是样式,不过有点区别
  				render: function() {
  				  return (
  				    <div>
  				      <h3>TODO</h3>
  				      // 列表项
  				      <TodoList items={this.state.items} />
  				      // 输入区,form直接绑定按钮的提交功能?
   				      <form onSubmit={this.handleSubmit}>
   				       // input直接关联属性,在onchange里设置setState,从而触发重新渲染
   				       <input onChange={this.onChange} value={this.state.text} />
   				       // 按钮不用添加事件?
   				       <button>{'Add #' + (this.state.items.length + 1)}</button>
    				  </form>
    				</div>
  				 );
 				 }
				});

				ReactDOM.render(<TodoApp />, mountNode);
				
		2016年04月11日13:48:00
		
		2016年04月11日13:56:28
			#react native 语法基础#
				调用this.setState()时,会再次触发render
				2016年04月11日14:49:54
				类调用的方法一般都是类方法,用this.function来调用
				例如
				class Hello extends component{
				render(){
					return this.renderLoadingView();
				}
				
				renderLoadingView(){
					return(
					<View>
						<Text>在加载~~~</Text>
					</View>
					);}	
				}
				
			样式用
				var style = StyleSheet.create(
					{
						container:{
							flex:1,
							
						},	
					
					
					});
				放在js文件的最后,有三个好处
				1.不可更改
				2.不可见
				3.只要加载一次,不用每次render都加载
				
				数据的表示方式是:{ 数据内容 }
				
				2016年04月11日15:35:26
					#react native 语法基础#
						加载图片时的注意点
						1. 加载本地图片时,需要不同尺寸,相同内容的图片,以适应不同的屏幕
						2. 加载网络图片,需要手动指定图片尺寸
							<Image source ={{uri: 'https://facebook.github.io/react/img/logo_og.png'}}
							style = {{width: 400, height: 400}}/>
							另外要注意,这里的uri:xxx指定了一个uri属性为xxx的对象
						
						3. 图片性能					
							名词解释:掉帧
								UI丢失应该加载的图片
								
							FPS:帧率
								每秒应该展现的图片数,标准为60,也就是每16ms需要生成一张图片,倘若开发者和UI系统无法在此时间内生成一张图片,则界面会卡顿.
							react的运行机制是:由JS运行业务逻辑,然后将数据更新到原生界面.
							在push新页时,js需要绘制所有组件,所以必然会占用时间,引起页面卡顿

							
					2016年04月11日16:34:51					
						#react native 语法基础#
							DOM:可用于管理html和XML文件里的元素,包括增删改查
							
						重要:this.prop用于传递数据(包括文件内和文件之间)
						   this.state用于刷新视图

						   
					2016年04月12日10:50:46
						#web布局基础#
							css文本渲染样式时针对的是class
							.flex-container{
								………………
								………………
							}							
							<Span class="flex-container" ></Span>
							
							
							style渲染样式时针对的是标签
							<head>
								<style type="text/css">
										body {background-color: red}
										p {margin-left: 20px}
								</style>
							</head>							
							<span class="flex-container"> 
								<span class="flex-item">1</span>
								<span class="flex-item">5</span>
							</span>
							
							
						#react技术#
							原生特性
								js可以写原生代码,也可以访问平台.我们的第一步是封装原生模块供react使用
								
								封装的第一步:
									让原生代码成为RCTBridgeModule的协议,比如这样
									@interface CalendarManager : NSObject <RCTBridgeModule>
									@end	
								
								第二步,在@implement @end里,添加协议的实现
								
									RCT_EXPORT_MODULE();
								
								第三步,给要导出的方法添加RCT_EXPORT_METHOD()宏
									RCT_EXPORT_METHOD(addEvent:(NSString *)name location:(NSString *)location)
									被导出的方法的返回值必须是void
									
								第四步 在js里调用
									var CalendarManager = require('react-native').NativeModules.CalendarManager;
									CalendarManager.addEvent('name', 'Shanghai');
								
								第五步  有回调时
									RCT_EXPORT_METHOD(findEvents:(RCTResponseSenderBlock)callback)
									{
									    // 获取值,是一个数组
										NSArray *events = 
										// 传值
										callback( events);
									}
									
									在js里
									var CalendarManager = require('react-native').NativeModules.CalendarManager;
									CalendarManager.findEvent((Events)=> {
										
									})
									
						#react技术#
								#语法#
								alert时可直接调跨平台接口,alert,在IOS中可用alertIOS
									alertIOS.alert(title,content,[{btn1:'text' onPress: 匿名方法 }])
									
								#回调#
									原生这边,
									需要 
										1 类遵守协议 <RCTBridgeModule>
										2 需要被调用的方法以宏	RCT_EXPORT_METHOD()包含
											方法的返回值必须为void
										
									JS这边
									需要
										1 import NativeModules
										2 var Manager = require('react-native').NativeModules.AlertManager
										3 在代码里调用
											<Text onPress = Manager.alertWithTags( {title:'?',message:'!!!'} ), (e)=>{} > 
											</Text>
											
								#ES5,ES6的语法区别#
										引用react模块：
												es5下
												var React = require('react-native')
												var {
										

												} = React;


												es6下
												import React,{


												} from 'react-native';

											导出模块（多用于自定义模块）	
												es5下，分两步
												var MyComponent = React.Create({
										
												});

												module.exports = MyComponent;
										
												es6下(在定义之前添加export default class以说明可外调 )
												export default class MyComponent extends Component{
													…………
												}

											引用模块
												ES5
													var MyComponent = require('./MyComponent.js');	

												ES6
													import MyComponent from './MyComponent.js';
												
								#react语法#
									flex-box的常用属性
											对container
												可以指定内部item在竖轴上的对齐方式, 用属性align-content
												flex-end靠到竖轴的最下端 ,center聚在竖轴的中心等
												
											也可以指定item的间距
												space-around:每个item周围都环绕一圈空白
												
											定义属性时,一般会定义针对特定组件的属性.一些共用的属性会单独列出,比如
												height400:{
													height:400,
												},
												
											view可以是容器,也可以是容器里的item
													用flexDirection可以指定内部item的排列方式(column 或 row)
										
													
										在样式设置里,属性项除了表示为十进制的数字之外,都要以''来包括
										每个组件最基本的属性
											一层套一层,从内到外依次是
												content, padding, border, margin
												模型叫做盒子模型,一个盒子套一个
												
												
								#前端知识#
										菜单有丰富多彩的样式
											比如列表式
											比如tab层叠式
											比如折叠式
											比如伸缩式
											
													
										*概念
										
											
											[选择器的组合]
												标志类,表示交集   p.special  标志为p且class为special的元素
												标志1,标志2  表示合集    p,.special 它们都用此样式
												标志1/类一/id1 标志2/类二/id2 表示元素里嵌套元素的样式  p span  
												并且还可以传到更深层的嵌套
												
												标志1/类一/id1>标志2/类二/id2 表示元素里嵌套元素的样式  p>span
												不可用传到更深的层
												
												
											[后代选择器]	
												p span{
													color:red;
												}												
												标签嵌套标签时,可用此语法定义被嵌套标签的样式
											
											W3C:网页方面的标准化民间组织,主要工作是制定web规范的建议
											
											[全局选择器是*,传染所有的标志]
												表示所有标志都用此样式
											
											*块元素
												会自带新的开始行,例如<p>(段楼),<table>(表格)
												
											*内联
												不用新的开始行,例如<span>(多用作段落里部分文本的容器), <img>(图像)
											
											DOM
												将文档看成一个对象,文档一般就是html,文档里的组件(component)可以用object.attribute的方式来访问
											
											容器
												在DOM里,每一个标志就是一个容器,容器里可以包含子容器,子容器传染了父容器的特性
											
											层叠样式的核心含义
												当一个元素里有多个样式关联到同一个属性时,显示按照优先级来
													行内样式> id样式> 类样式> 标志样式
											
											盒子模型(重点)		
												页面上的任一元素均可视为盒子
												需要关注:
													盒子的内部结构
													盒子之间的关系
												重要属性:padding-border-margin 描述了矩形的布局形式
											
											Div标签,用于包裹内容,实现样式不同的排版,就是指定内容外包裹的padding,border,margin的样式.比如
											<!doctype html>
											<!--css的各种调用方法-->
											<html lang="en">
											<head>
  											  <meta charset="utf-8" ;http-equiv="content-type" ; content="text/html" >
   											 <style>
     											  div{
     											      border-width: 6px;
     											      border-color: #000000;
     											      margin: 20px;
       											    padding: 5px;
     											      background-color: #FFFFCC;
    											   }
  											  </style>
  											  <title>继承关系</title>
											</head>
 											   <body>
  											  <div style="border-style: dashed" >  The  border-style of dashed </div>
 											   <div style="border-style: dotted" >  The  border-style of dotted </div>
 											   <div style="border-style: double" >  The  border-style of double </div>
  											  <div style="border-style: groove" >  The  border-style of groove </div>
  											  <div style="border-style: inset" >  The  border-style of inset </div>
  											  <div style="border-style: outset" >  The  border-style of outset </div>
 											   </body>
											</html>
											
											可在包裹的内容外出现图案不同的边框
											
											层叠样式,覆盖样式的差别
												层叠是当多个[样式]带来同一属性时,优先级高的覆盖优先级低的
												覆盖样式是指在边框样式( div )带来的属性和内嵌属性重复时,取后出现的属性
											
												
											缩写属性
												多个属性可在同一个标志里赋值
												例如
													border: 2px black groove就定义了边框宽度,颜色和样式三种属性
												
											框的各边分别赋属性
												例如
													border-color:red gray orange blue  顺时钟赋值  上 右 下 左 
												
										*技巧
											结构标志:不显示内容,是框架.比如 <ul> <table>等
											内容标签:用于显示内容
											
											html加载CSS时,
												如果只有一个CSS要导入,最好用链接式,这样一出来就是有样式的界面. 用link标签来 <link href=""; content="" />
												
												还有直白的导入式:
												<style type="text/css">
													.red{
														color:red;
													}
													.green{
														color:green;
													}													
												</style>
												
												如果有多个,用链接引入css目录,再在目录里用导入法引用其他
												如果用JS来导入CSS,要用链接式
												
											
												层级式
													       <ul>
            													  <li>second link
                													   <ul>
                    												       <li>third link</li>
                													   </ul>
            													       </li>
            													  <li>second link2</li>
        											       </ul>
        											       
        											   <ul> 次级的<li>元素就是内容
        											   在<li>里面,可以嵌套
        											   		<ul>
        											   			<li></li>
        											   		</ul>
											


			